
#' @title Bayes
#'
#' @description
#' this function computes several features from posterior chains included in a list generated by the function bunny.
#'
#' @param params A parameter file generated by the functions iCreateParam or CreateParam.
#' @param bunny A list generated by the function bunny containing all model specifications and posterior samples of inferences
#' @param HPD a scalar from 0 to 1 specifying the amount of probability within the highest posterior density interval to be calculated. This argument applies to Model mean, Treatments, Covariates, Contrasts and Variance Components.
#' @param P0 Logical (default=TRUE). If TRUE, the probability of the estimate to be greater than 0 if the median is positive, or lower than 0 if the median is negative, will be computed. Note that in case of the contrasts between Treatments being ratios, prob >1 or prob<1 will be computed. This argument applies to all Treatments, Contrasts and Covariates.
#' @param K Logical (default=FALSE). If TRUE, a guaranteed value of the estimate with probability Kprob is computed. Only displayed if K has the same sign as the median of the posterior chain. This argument applies to all Treatments, Contrasts, Covariates and Variance Components.
#' @param probK a numeric value from 0 to 1 indicating the probability to consider in K. If K=TRUE and probK is not specified, a default value of 0.8 will be used.
#' @param PR Logical (default=FALSE). If TRUE, the probability of the posterior chain to be greater than a relevant value (R) if the median is positive, or lower than R if the median is negative, will be computed. This argument applies to Contrasts.
#' @param R a vector containing a relevant value per each trait. If PR=TRUE, this argument is mandatory. Note that in case of the contrasts between Treatments being ratios, R should be considered in Percentage (For example 1.1 for 10%). Suggested values are 1/3 of the sd of the trait for differences, and 10% for ratios.
#' @param PS Logical (default=FALSE). If TRUE, the probability of similarity of the estimate is computed. This is, the posterior probability that the estimate is between -R and R (or between 1/R and R if its a ratio)
#' @param SaveTable Logical (default=TRUE). If TRUE, inferences of the posterior distributions printed in the prompt are saved in an .csv file.
#' @param plot Logical (default=FALSE). If TRUE, posterior distributions of contrasts are plot and saved in a tiff file, highlighting P0 and PR if applicable.
#'
#' @return a list with the inferences computed for each trait
#' @import HDInterval
#' @import ggplot2
#' @import tidyr
#' @export
#'
#' @examples
#'
#'
#'

Bayes <- function(params, bunny, HPD=0.95, P0=TRUE,
                  K=FALSE, probK=0.80,
                  PR=FALSE, R=FALSE,PS=FALSE,
                  SaveTable=FALSE, plot=FALSE){

  cat(" Bayes Starting ... \n")
  # Ensure that R has an entry for each trait if PR or PS are TRUE
  if((PR || PS) && (!is.vector(R) || length(R) != length(bunny))) {
    stop("When PR is TRUE, R must be a vector with one entry per trait.")
  }

  # Helper function defined within bayes
  ComputeInferences <- function(samples, HPD=0.95, P0=TRUE, K=FALSE, probK=0.8, PR=FALSE, R=NULL, PS=FALSE, askCompare="D") {

    # Validation and Defaults
    if ((PR || PS) && is.null(R)) {
      stop("When PR or PS is TRUE, R must be specified.")
    }

    if (PR && is.null(R)) {
      stop("PR is TRUE but R is not specified. Please provide a value for R.")
    }

    est <- median(samples)
    meanVal <- mean(samples)
    sdVal <- sd(samples)
    hpdInterval <- hdi(samples, credMass = HPD)

    # Initialize P0 and prValue
    p0 <- NA
    kGuaranteed <- NA
    pr <- NA
    ps <- NA

    # Calculate P0 based on the sign of the median and on params$askCompare
    if (P0) {
      if (askCompare == "D") {
        p0 <- if(est > 0) { length(which(samples > 0)) / length(samples) } else { length(which(samples < 0)) / length(samples) }
      } else if (askCompare == "R") {
        p0 <- if(est > 1) { length(which(samples > 1)) / length(samples) } else { length(which(samples < 1)) / length(samples) }
      }
    }

    #Calculate Guaranteed Value only if have the same sign as the median
    if (K) {
      quantileValue <- quantile(samples, probs = c(probK, 1 - probK))
      if (est > 0) {
        kGuaranteed <- ifelse(quantileValue[1] > 0, quantileValue[1], NA)  # For positive estimates, use lower quantile if positive
      } else {
        kGuaranteed <- ifelse(quantileValue[2] < 0, quantileValue[2], NA)  # For negative estimates, use upper quantile if negative
      }
    }

    # Calculate Probability of Relevance and Probability of similarity
    if ((PR || PS) && !is.null(R)) {
      if (askCompare == "D") {
        if (PR) {pr <- if(est > 0) { length(which(samples > R)) / length(samples) } else { length(which(samples < -R)) / length(samples) }}
        if (PS) {ps <- length(which(samples >= -R & samples <= R)) / length(samples)}
      } else if (askCompare == "R") {
        if (PR) {pr <- if(est > 1) { length(which(samples > R)) / length(samples) } else { length(which(samples < 1/R)) / length(samples) }}
        if (PS) {ps <- length(which(samples >= 1/R & samples <= R)) / length(samples)}
      }
    }

    return(c(Median=est,
             Mean=meanVal,
             SD=sdVal,
             HPD_low=hpdInterval[1],
             HPD_up=hpdInterval[2],
             P0=p0,
             K=kGuaranteed,
             PR=pr, PS=ps))
  }


  #1 ) Apply the computeInferences function to each posterior chain
  out_bayes <- list()
  for (trait in names(bunny)) {
    cat("\n")
    cat("\n\nProcessing Trait:", trait, "\n")

  # Extract data for the current trait
  traitResults <- list()
  traitResults_df<-data.frame()

  # Extract and process ModelMean
  cat("---------------------------------------------------\n")
  cat(" Model Mean\n")

  traitResults[["ModelMean"]] <- computeInferences(as.numeric(bunny[[trait]]$ModelMean[,1]), askCompare=params$askCompare, HPD, P0=FALSE, K=FALSE, probK=NULL, PR=FALSE, R=NULL, PS=FALSE)
  m<-traitResults[["ModelMean"]]
  cat("Median: ", m["Median"], "\n")
  cat("Mean: ", m["Mean"], "\n")
  cat("SD: ", m["SD"], "\n")
  cat("HPD Lower: ", m[4], "\n")
  cat("HPD Upper: ", m[5], "\n")
  cat("---------------------------------------------------\n")


  # Extract and process ResVariances
  cat("---------------------------------------------------\n")
  cat(" Residual Variance\n")
  traitResults[["ResVariance"]] <- computeInferences(as.numeric(bunny[[trait]]$ResVariance[,1]), askCompare=params$askCompare, HPD, P0=FALSE, K=FALSE, probK=NULL, PR=FALSE, R=NULL, PS=FALSE)
  m<-traitResults[["ResVariance"]]
  cat("Median: ", m["Median"], "\n")
  cat("Mean: ", m["Mean"], "\n")
  cat("SD: ", m["SD"], "\n")
  cat("HPD Lower: ", m[4], "\n")
  cat("HPD Upper: ", m[5], "\n")
  cat("---------------------------------------------------\n")

  # Define other components to process
  components <- c("treatMeans","Compare", "Cov", "RandomVariances")
  for (comp in components) {
    # Initialize a list to hold inferences of each component
    compResults <- list()

    if (length(bunny[[trait]][[comp]]) > 0) {
      cat(paste("Inferences of posterior chains for", comp, "\n"))
      cat("---------------------------------------------------\n")

      # Handling nested lists in treatMeans and Compare
      if (comp %in% c("treatMeans", "Compare")) { #,
        # Iterate through each list element
        for (elem in names(bunny[[trait]][[comp]])) {
          # Each element may contain multiple subelements
          elemResults <- list()
          for (subElem in names(bunny[[trait]][[comp]][[elem]])) {
            samples <- as.numeric(bunny[[trait]][[comp]][[elem]][[subElem]])
            if (PR||PS) {R<-R[which(names(bunny) == trait)]}
            elemResults[[subElem]] <- computeInferences(samples, askCompare=params$askCompare, HPD, P0, K, probK, PR, R, PS)
            cat(paste(elem, subElem, "\n"))
            m<-elemResults[[subElem]]
            cat("Median: ", m["Median"], "\n")
            cat("Mean: ", m["Mean"], "\n")
            cat("SD: ", m[3], "\n")
            cat("HPD Lower: ", m[4], "\n")
            cat("HPD Upper: ", m[5], "\n")
            if (P0) {cat("P0: ", m["P0"], "\n")}
            if (K) {cat("Guaranteed Value with prob", probK, ": ", m[7], "\n")  }
            if (comp %in% c("Compare")){
              if (PR){ cat("PR with R", R[which(names(bunny) == trait)], ": ", m["PR"], "\n")}
              if (PS){ cat("PS with R", R[which(names(bunny) == trait)], ": ", m["PS"], "\n")}
               }
            cat("---------------------------------------------------\n")
           }
          }
        compResults[[elem]] <- elemResults
        } #end for treatmeans and compare

      if (comp %in% c("Cov", "RandomVariances")) { # For Cov and RandomVariances which are not deeply nested
        for (col in names(bunny[[trait]][[comp]])) {
            samples <- as.numeric(bunny[[trait]][[comp]][col][, 1])
            compResults[[col]] <- computeInferences(samples, askCompare=params$askCompare, HPD, P0, K, probK, PR=FALSE, R=NULL, PS=FALSE)
            m<-compResults[[col]]
            cat(paste(comp, col, "\n"))
            cat("Median: ", m["Median"], "\n")
            cat("Mean: ", m["Mean"], "\n")
            cat("SD: ", m["SD"], "\n")
            cat("HPD Lower: ",  m[4], "\n")
            cat("HPD Upper: ",  m[5], "\n")
            if (comp %in% c("Cov")){
              if (P0) {cat("P0: ", m["P0"], "\n")}
              if (K) {cat("Guaranteed Value with prob", probK, ": ", m[7], "\n")}
              }
            cat("---------------------------------------------------\n")
          }
        } #end for cov and random var
      }
     traitResults[[comp]] <- compResults

    }

  out_bayes[[trait]] <- traitResults

  } #End of the loop within each trait


  #2) If SaveTable=T out_bayes should be writen down in a csv file

  if (SaveTable) {
        # Helper function to recursively extract numeric vectors and their paths
        extract_numeric_vectors <- function(list_in, path = NULL, results = list()) {
          if (is.list(list_in)) {
            for (key in names(list_in)) {
              new_path <- c(path, key)
              results <- extract_numeric_vectors(list_in[[key]], new_path, results)
            }
          } else if (is.numeric(list_in)) {
            row_name <- paste(path, collapse = "_")
            results[[row_name]] <- setNames(as.data.frame(t(list_in), stringsAsFactors = FALSE), names(list_in))
          }
          return(results)
        }

        # Adjust function to unify column names for K
        unify_k_column <- function(numeric_vector_list) {
          lapply(numeric_vector_list, function(row_df) {
            colnames(row_df) <- gsub("^K\\..*", "K", colnames(row_df))
            return(row_df)
          })
        }

        # Extract numeric vectors and their paths as dataframe rows and unify columns K to avoid trouble
        numeric_vectors <- extract_numeric_vectors(out_bayes)
        numeric_vectors <- unify_k_column(numeric_vectors)

        # If there are no numeric vectors extracted, return an empty dataframe
        if (length(numeric_vectors) == 0) {
          cat("No numeric vectors found in the list.")
          df <- data.frame()
        } else {
          # Find all unique column names across extracted rows
          all_column_names <- unique(unlist(lapply(numeric_vectors, names)))

          # Standardize rows to have the same columns
          standardized_rows <- lapply(numeric_vectors, function(row) {
            missing_columns <- setdiff(all_column_names, names(row))
            if (length(missing_columns) > 0) {
              for (col in missing_columns) {
                row[[col]] <- NA  # Fill missing columns with NA
              }
            }
            row[all_column_names]  # Ensure consistent column order
          })

          # Combine rows into a single dataframe
          df <- do.call(rbind, standardized_rows)
          # Optionally, set row names
          rownames(df) <- names(standardized_rows)
        }

        write.csv(df, file="Inferences_PosteriorChains.csv")
      }

  #3) If plot=T make plots of th contrasts

  if (plot && length(bunny[[trait]][["Compare"]]) > 0) {
    for (trait in names(bunny)) {

      #Prepare the dataframe
      #Helper function to extract data from list (same lenght)
      extract_list_data <- function(my_list){
        combined_df <- data.frame()
        # Iterate over each element in the list
        for (elem in names(my_list)) {
          for (subElem in names(my_list[[elem]])) {
            # Extract the vector
            samples <- as.numeric(my_list[[elem]][[subElem]])
            # Create a temporary data frame with this vector as a column
            # Use the combination of elem and subElem as the column name
            temp_df <- data.frame(samples)
            names(temp_df) <- paste(elem, subElem, sep = "_")
            # Bind the temp_df to the combined_df by columns
            if (ncol(combined_df) == 0) {
              combined_df <- temp_df
            } else {
              combined_df <- cbind(combined_df, temp_df)
            }
          }
        }
        return(combined_df)
      }
      plot_data<-extract_list_data(bunny[[trait]][["Compare"]])

      # Convert the wide-format dataframe to a long-format dataframe for plotting
      plot_data_long <- pivot_longer(plot_data, cols = everything(), names_to = "comparison", values_to = "value")

      #Make the plot
      cPlot <- ggplot(plot_data_long, aes(x = value, y = comparison)) +  # Ensure 'condition' is defined as per your logic
        stat_halfeye(fill="lightgreen", color="black") +
        theme_classic() +
        labs(
          y = "Contrast Between Treatments",
          x = trait  # Setting the trait name as the x-axis label
        ) +
        theme(legend.position = "none")

      # Add a dashed line at x=0 if P0 is TRUE
      if (P0) {
        cPlot <- cPlot + geom_vline(xintercept = if(params$askCompare == "D") 0 else 1, linetype = "dashed", color = "red")
      }

      # Add dashed lines for R values if PR or PS are TRUE
      if (PR || PS) {
        # Adjust R value based on the specific trait
        R<-R[which(names(bunny) == trait)]
        if(params$askCompare == "D") {r_values <- c(-R, R)} else {r_values <- c(1/R, R)}
        cPlot <- cPlot + geom_vline(xintercept = r_values, linetype = "dashed", color = "red")

      }

      # Display the plot
      print(cPlot)

      # Save the plot as a TIFF file
      file_name <- paste0("Contrasts_posterior_plot_", trait, ".tiff")
      ggsave(file_name, plot = cPlot, device = "tiff", width = 10, height = 8, units = "in", dpi = 300)

    }


  }
  return(out_bayes) #Always return the list
  cat("\n")
  cat("Progam finsihed!! :) ")

} #End of the function




