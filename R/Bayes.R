
#' @title Bayes
#'
#' @description
#' This function computes posterior chain analysis with Bayesian Statistics. Posterior chains need to be contained in a list generated by the `bunny` function. It evaluates model means, treatments, covariates, contrasts, and variance components using Bayesian inference methods.
#'
#' @details
#' The `Bayes` function facilitates comprehensive analysis of posterior distributions resulting from Bayesian mixed models. It allows for detailed examination of model parameters, providing insights into the statistical relevance, and uncertainty of estimates. It emphasizes probabilistic interpretations, offering a nuanced understanding of model outputs beyond point estimates.
#'
#' @param params A parameter file generated by `iCreateParam` or `CreateParam`.
#' @param bunny A list produced by the `bunny` function, including all model specifications and posterior samples of inferences for different traits.
#' @param HPD A scalar value between 0 and 1 specifying the desired probability to compute the highest posterior density (HPD) interval. Default value is 0.95. The HPD interval is computed for model mean, treatments, covariates, contrasts, and variance components.
#' @param P0 A logical (default is `TRUE`). If `TRUE`, computes the probability that the posterior distribution is greater than zero if the median is positive, or less than zero if the median is negative. This applies to treatments, contrasts, and covariates. For contrasts between treatments expressed as ratios, it computes probabilities of being greater than or less than 1.
#' @param K A logical(default is `FALSE`). If `TRUE`, computes a "guaranteed" value of the posterior distribution with a specified probability (`probK`). This value is only displayed if its sign matches the sign of the median of the posterior distribution. Applies to treatments, contrasts, covariates, and variance components.
#' @param probK A numeric value between 0 and 1 specifying the probability threshold for computing the guaranteed value when `K` is `TRUE`. If `K` is `TRUE` and `probK` is not specified, a default value of 0.80 is used.
#' @param PR A logical (default is `FALSE`). If `TRUE`, computes the probability that the posterior distribution is greater than a relevant value (`R`) if the median is positive, or less than `R` if the median is negative. Applies to contrasts only.
#' @param R A numeric vector containing a relevant value for each trait. If `PR` is `TRUE`, this argument is mandatory. For contrasts between treatments expressed as ratios, `R` should be considered in percentage (e.g., 1.1 for a 10 per cent increase). Suggested values are one-third of the standard deviation of the trait for differences, and 10 per cent for ratios.
#' @param PS A logical (default is `FALSE`). If `TRUE`, computes the probability of similarity, i.e., the probability that the posterior distribution lies within `-R` to `R` (or between `1/R` and `R` if it's a ratio). Applies to contrasts only.
#' @param SaveTable  A logical flag (default is `TRUE`). If `TRUE`, the inferences of posterior distributions printed to the console are also saved in a CSV file.
#' @param plot A logical flag (default is `FALSE`). If `TRUE`, generates and saves plots of posterior distributions for contrasts in .tiff format, highlighting `P0` and `PR` values if applicable.
#'
#' @return Returns a list with computed inferences for each trait, including model means, treatments, contrasts, covariates, variance components, and probabilities associated with specified thresholds.
#' @importFrom HDInterval hdi
#' @import ggplot2
#' @import tidyr
#' @import openxlsx
#' @importFrom ggdist stat_halfeye
#'
#' @examples
#' \dontrun{
#' # Example 1: Basic Usage for Model Mean and Treatments Analysis
#' bayes_analysis_basic <- Bayes(
#'   params = param_file,
#'   bunny = bunny_results)
#'
#' # Example 2: Customizing analysis with a relevance threshold and guaranteed value probabilit
#' bayes_advanced_analysis <- Bayes(
#'   params = param_file,
#'   bunny = bunny_results,
#'   HPD = 0.95,
#'   K = TRUE, # Compute a guaranteed value of the estimate
#'   probK = 0.90, # With 90% probability
#'   PR = TRUE, # Compute the probability of the posterior chain being greater than a relevant value
#'   R = c(0.3, 0.1), # Assuming two traits with relevant values specified
#'   PS = TRUE, # Compute probability of similarity
#'   SaveTable = TRUE, # Save detailed inferences in a CSV file
#'   plot = TRUE) # Additionally, generate plots for contrasts)
#'
#' # Example 3: Analyzing treatment ratios of a single trait
#'bayes_ratio_analysis <- Bayes(
#'  params = param_file,
#'  bunny = bunny_results,
#'  HPD = 0.95,
#'  P0 = TRUE, # Examining probabilities related to ratios rather than differences
#'  PR = TRUE, # Assessing whether treatment ratios exceed a relevant threshold
#'  R = c(1.1), # Relevant value indicating a 10% increase is significant
#'  plot = TRUE) # Visualizing the distribution of ratios and relevant thresholds
#'}
#'
#' @export


Bayes <- function(params, bunny, HPD=0.95, P0=TRUE,
                  K=FALSE, probK=0.80,
                  PR=FALSE, R=FALSE,PS=FALSE,
                  SaveTable=TRUE, plot=FALSE){

  cat(" Bayes Starting ... \n")
  # Ensure that R has an entry for each trait if PR or PS are TRUE
  if((PR || PS) && (!is.vector(R) || length(R) != length(bunny))) {
    stop("When PR is TRUE, R must be a vector with one entry per trait.")
  }


  #1 ) Apply the ComputeInferences function to each posterior chain
  out_bayes <- list()
  for (trait in names(bunny)) {
    cat("\n")
    cat("\n\nProcessing Trait:", trait, "\n")

  # Extract data for the current trait
  traitResults <- list()
  traitResults_df<-data.frame()

  # Extract and process ModelMean
  cat("---------------------------------------------------\n")
  cat(" Model Mean\n")

  traitResults[["ModelMean"]] <- ComputeInferences(as.numeric(bunny[[trait]]$ModelMean[,1]), askCompare=params$askCompare, HPD, P0=FALSE, K=FALSE, probK=NULL, PR=FALSE, R=NULL, PS=FALSE)
  m<-traitResults[["ModelMean"]]
  cat("Median: ", m["Median"], "\n")
  cat("Mean: ", m["Mean"], "\n")
  cat("SD: ", m["SD"], "\n")
  cat("HPD Lower: ", m[4], "\n")
  cat("HPD Upper: ", m[5], "\n")
  cat("---------------------------------------------------\n")


  # Extract and process ResVariances
  cat("---------------------------------------------------\n")
  cat(" Residual Variance\n")
  traitResults[["ResVariance"]] <- ComputeInferences(as.numeric(bunny[[trait]]$ResVariance[,1]), askCompare=params$askCompare, HPD, P0=FALSE, K=FALSE, probK=NULL, PR=FALSE, R=NULL, PS=FALSE)
  m<-traitResults[["ResVariance"]]
  cat("Median: ", m["Median"], "\n")
  cat("Mean: ", m["Mean"], "\n")
  cat("SD: ", m["SD"], "\n")
  cat("HPD Lower: ", m[4], "\n")
  cat("HPD Upper: ", m[5], "\n")
  cat("---------------------------------------------------\n")

  # Define other components to process
  components <- c("treatMeans","Compare", "Cov", "RandomVariances")
  for (comp in components) {
    # Initialize a list to hold inferences of each component
    compResults <- list()

    if (length(bunny[[trait]][[comp]]) > 0) {
      cat(paste("Inferences of posterior chains for", comp, "\n"))
      cat("---------------------------------------------------\n")

      # Handling nested lists in treatMeans and Compare
      if (comp %in% c("treatMeans", "Compare")) { #,
        # Iterate through each list element
        for (elem in names(bunny[[trait]][[comp]])) {
          # Each element may contain multiple subelements
          elemResults <- list()
          for (subElem in names(bunny[[trait]][[comp]][[elem]])) {
            samples <- as.numeric(bunny[[trait]][[comp]][[elem]][[subElem]])
            if (PR||PS) {r<-R[which(names(bunny) == trait)]}
            pR_value <- ifelse(comp == "treatMeans", FALSE, PR)
            pS_value <- ifelse(comp == "treatMeans", FALSE, PS)
            elemResults[[subElem]] <- ComputeInferences(samples, askCompare=params$askCompare, HPD, P0, K, probK, PR=pR_value, R=r, PS=pS_value)
            cat(paste(elem, subElem, "\n"))
            m<-elemResults[[subElem]]
            cat("Median: ", m["Median"], "\n")
            cat("Mean: ", m["Mean"], "\n")
            cat("SD: ", m[3], "\n")
            cat("HPD Lower: ", m[4], "\n")
            cat("HPD Upper: ", m[5], "\n")
            if (P0) {cat("P0: ", m["P0"], "\n")}
            if (K) {cat("Guaranteed Value with prob", probK, ": ", m[7], "\n")  }
            if (comp %in% c("Compare")){
              if (PR){ cat("PR with R", R[which(names(bunny) == trait)], ": ", m["PR"], "\n")}
              if (PS){ cat("PS with R", R[which(names(bunny) == trait)], ": ", m["PS"], "\n")}
               }
            cat("---------------------------------------------------\n")
           }
          compResults[[elem]] <- elemResults
          }
        } #end for treatmeans and compare

      if (comp %in% c("Cov", "RandomVariances")) { # For Cov and RandomVariances which are not deeply nested
        for (col in names(bunny[[trait]][[comp]])) {
            samples <- as.numeric(bunny[[trait]][[comp]][col][, 1])
            #Do not compute P0 if its a Variance
            p0_value <- ifelse(comp == "RandomVariances", FALSE, P0)
            compResults[[col]] <- ComputeInferences(samples, askCompare=params$askCompare, HPD, P0=p0_value, K, probK, PR=FALSE, R=NULL, PS=FALSE)
            m<-compResults[[col]]
            cat(paste(comp, col, "\n"))
            cat("Median: ", m["Median"], "\n")
            cat("Mean: ", m["Mean"], "\n")
            cat("SD: ", m["SD"], "\n")
            cat("HPD Lower: ",  m[4], "\n")
            cat("HPD Upper: ",  m[5], "\n")
            if (comp %in% c("Cov")){
              if (P0) {cat("P0: ", m["P0"], "\n")}
              if (K) {cat("Guaranteed Value with prob", probK, ": ", m[7], "\n")}
              }
            cat("---------------------------------------------------\n")
          }
        } #end for cov and random var
      }
     traitResults[[comp]] <- compResults

    }

  out_bayes[[trait]] <- traitResults

  } #End of the loop within each trait


  #2) If SaveTable=T (Default) out_bayes should be writen down in a csv file

  if (SaveTable) {
        # Helper function to recursively extract numeric vectors and their paths
        extract_numeric_vectors <- function(list_in, path = NULL, results = list()) {
          if (is.list(list_in)) {
            for (key in names(list_in)) {
              new_path <- c(path, key)
              results <- extract_numeric_vectors(list_in[[key]], new_path, results)
            }
          } else if (is.numeric(list_in)) {
            row_name <- paste(path, collapse = "_")
            results[[row_name]] <- setNames(as.data.frame(t(list_in), stringsAsFactors = FALSE), names(list_in))
          }
          return(results)
        }

        # Adjust function to unify column names for K
        unify_k_column <- function(numeric_vector_list) {
          lapply(numeric_vector_list, function(row_df) {
            colnames(row_df) <- gsub("^K\\..*", "K", colnames(row_df))
            return(row_df)
          })
        }

        # Extract numeric vectors and their paths as dataframe rows and unify columns K to avoid trouble
        numeric_vectors <- extract_numeric_vectors(out_bayes)
        numeric_vectors <- unify_k_column(numeric_vectors)

        # If there are no numeric vectors extracted, return an empty dataframe
        if (length(numeric_vectors) == 0) {
          cat("No numeric vectors found in the list.")
          df <- data.frame()
        } else {
          # Find all unique column names across extracted rows
          all_column_names <- unique(unlist(lapply(numeric_vectors, names)))

          # Standardize rows to have the same columns
          standardized_rows <- lapply(numeric_vectors, function(row) {
            missing_columns <- setdiff(all_column_names, names(row))
            if (length(missing_columns) > 0) {
              for (col in missing_columns) {
                row[[col]] <- NA  # Fill missing columns with NA
              }
            }
            row[all_column_names]  # Ensure consistent column order
          })

          # Combine rows into a single dataframe
          df <- do.call(rbind, standardized_rows)
          colnames(df)[4]<-"HPD_lower"
          colnames(df)[5]<-"HPD_upper"
          # set row names
          rownames(df) <- names(standardized_rows)
        }

        openxlsx::write.xlsx(df, "Results.xlsx", overwrite = TRUE, rowNames = TRUE)
        #write.csv(df, file="Results.csv")
      }

  #3) If plot=T make plots of the contrasts

  if (plot && length(bunny[[trait]][["Compare"]]) > 0) {
    for (trait in names(bunny)) {

      #Prepare the dataframe
      #Helper function to extract data from list (same lenght)
      extract_list_data <- function(my_list){
        combined_df <- data.frame()
        # Iterate over each element in the list
        for (elem in names(my_list)) {
          for (subElem in names(my_list[[elem]])) {
            # Extract the vector
            samples <- as.numeric(my_list[[elem]][[subElem]])
            # Create a temporary data frame with this vector as a column
            # Use the combination of elem and subElem as the column name
            temp_df <- data.frame(samples)
            names(temp_df) <- paste(elem, subElem, sep = "_")
            # Bind the temp_df to the combined_df by columns
            if (ncol(combined_df) == 0) {
              combined_df <- temp_df
            } else {
              combined_df <- cbind(combined_df, temp_df)
            }
          }
        }
        return(combined_df)
      }
      plot_data<-extract_list_data(bunny[[trait]][["Compare"]])

      # Convert the wide-format dataframe to a long-format dataframe for plotting
      plot_data_long <- pivot_longer(plot_data, cols = everything(), names_to = "comparison", values_to = "value")

      #Make the plot
      cPlot <- ggplot(plot_data_long, aes(x = value, y = comparison)) +  # Ensure 'condition' is defined as per your logic
        stat_halfeye(fill="lightgreen", color="black") +
        theme_classic() +
        labs(
          y = "Contrast Between Treatments",
          x = trait  # Setting the trait name as the x-axis label
        ) +
        theme(legend.position = "none")

      # Add a dashed line at x=0 if P0 is TRUE
      if (P0) {
        cPlot <- cPlot + geom_vline(xintercept = if(params$askCompare == "D") 0 else 1, linetype = "dashed", color = "red")
      }

      # Add dashed lines for R values if PR or PS are TRUE
      if (PR || PS) {
        # Adjust R value based on the specific trait
        r<-R[which(names(bunny) == trait)]
        if(params$askCompare == "D") {r_values <- c(-r, r)} else {r_values <- c(1/r, r)}
        cPlot <- cPlot + geom_vline(xintercept = r_values, linetype = "dashed", color = "red")

      }

      # Display the plot
      print(cPlot)

      # Save the plot as a TIFF file
      file_name <- paste0("Contrasts_posterior_plot_", trait, ".tiff")
      ggsave(file_name, plot = cPlot, device = "tiff", width = 10, height = 8, units = "in", dpi = 300)

    }


  }

  cat("\n")
  cat("Progam finsihed!! :) ")
  return(out_bayes) #Always return the list
} #End of the function




