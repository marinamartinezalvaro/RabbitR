
#' @title Bunny
#'
#' @description
#' this function fits a mixed-effects model with fixed effects, random effects, and interactions based on the provided parameter file. It conducts convergence diagnosis, computes LSMeans, and calculates contrasts between levels of treatments as indicated in the parameter file.
#'
#' @param params A parameter file generated by the functions iCreateParam or CreateParam.
#' @param Chain Logical (default=FALSE). If TRUE, all the samples of the posterior distributions of the estimated parameters are stored for each trait.
#' @return A list containing the samples of the posterior distributions of the estimated parameters.
#'
#' @examples
#' # Example usage:
#' # bunny(params = my_param_file, Chain = TRUE)
#' # bunny(params = my_param_file, Chain = FALSE)
#'
#' @return
#' @import MCMCglmm
#' @import coda
#' @import knitr
#' @import openxlsx
#' @import readxl
#' @export

Bunny <- function(params, Chain=FALSE) {

  # 1) Load the data
  # Determine the file extension
  fileExtension <- tools::file_ext(params$file.name)

  # Choose the reading function based on the file extension
  switch(fileExtension,
         csv = {
           data <- read.csv(params$file.name, na.strings=params$na.codes)
         },
         xls = {
           data <- read_excel(params$file.name)
         },
         xlsx = {
           data <- read_excel(params$file.name)
         },
         txt = {
           data <- read.table(params$file.name, na.strings=params$na.codes)
         },
         stop("Error: Unsupported file format")
  )

  # Additional processing for Excel files if needed
  if (fileExtension %in% c("xls", "xlsx")) {
    data[is.na(data)] <- NA  # Example: Converting custom NA codes if necessary
  }

  #Current version removes missing values in any of the right side of the model
  required_columns <-  unique(unlist(params[c("hTreatment", "hNoise", "hCov", "hInter", "hRand")]))
  # Delete rows with missing values in required columns
  before_na <- nrow(data)
  data <- data[complete.cases(data[, required_columns]), ]
  after_na <- nrow(data)
  cat("\n\n")
  cat("Warning: Removed", before_na - after_na, "rows due to missing values in model effects.\n")
  cat("\n")

  # 2) Arrange formula inputs

  # Combine hTreatment, hNoise, hCov and hInter with "+" to form the predictors part if they are not 0 (If are missing create params set them to 0)
  # Initialize an empty list to hold predictors that are not character(0)
  predictors <- list()

  # Check each component; if it's not character(0), add it to predictors
  if (length(params$hTreatment) > 0) {
    for (colName in params$hTreatment) {
      data[[colName]] <- as.factor(data[[colName]])
    }
    predictors <- c(predictors, paste(params$hTreatment, collapse = " + "))
  }
  if (length(params$hNoise) > 0) {
    for (colName in params$hNoise) {
      data[[colName]] <- as.factor(data[[colName]])
    }
    predictors <- c(predictors, paste(params$hNoise, collapse = " + "))
  }
  if (length(params$hCov) > 0) {
    predictors <- c(predictors, paste(params$hCov, collapse = " + "))
  }

  # FALTA 1: I need to modify this and make interactions as a new fixed effect
    # if (length(params$hInter) > 0) {  # I need to create a new Term.
    #   # In MCMCglmm, If only the interaction is to be used, I should use ':'. '*' includes both the main effects and the interaction term, but if main effects are to be included, user should indicate it in the params already.
    #   # Initialize an empty vector to store interaction terms
    #   interaction <- character(nrow(params$hInter))
    #
    #   # Loop through each row of the hInter matrix
    #   for (i in 1:nrow(params$hInter)) {
    #     # Create the interaction string and store it in the interaction vector
    #     interaction[i] <- paste(params$hInter[i, 1], params$hInter[i, 2], sep = ":")
    #   }
    #   predictors <- c(predictors, paste(interaction, collapse = " + "))
    # }

  # If there are no valid predictors, use "1" to indicate an intercept-only model
  predictors_formula <- if (length(predictors) == 0) "1" else paste(predictors, collapse = " + ")

  # fixed part of the formula changes through each trait
  fixed_formula <- list()
  for(hTrait in params$hTrait) {
    fixed_formula[hTrait] <- paste(hTrait, "~", predictors_formula)
  }

  # Random part of the formula
  if (length(params$hRand) > 0) {
  random_formula <- paste("~", paste(params$hRand, collapse = "+"))
  } else {
    random_formula <-0
  }

  #Make sure all data columns have the appropriate structure

  # Ensure hTreatment and hNoise are factors
  for (colName in c(params$hTreatment, params$hNoise)) {
    data[[colName]] <- as.factor(data[[colName]])
  }

  # Ensure hCov are treated as covariates (numerical)
  for (colName in params$hCov) {
      data[[colName]] <- as.numeric(data[[colName]])
  }

  # FALTA 2: Ensure Interaction to be factors or covariates
  # Simplified conversion based on typeInter for interaction variables in hInter
  # for (i in seq_len(nrow(params$hInter))) {
  #   for (varName in params$hInter[i, ]) {
  #     varType <- params$typeInter[i, params$hInter[i, ] == varName]
  #     # Convert to factor if specified as Factor (F)
  #     if (varType == "F") {
  #       data[[varName]] <- as.factor(data[[varName]])
  #     }
  #     # Convert to numeric if specified as Covariate (C) #FALTA! Program interactions between fixed effects and covariates
  #     else if (varType == "C") {
  #       data[[varName]] <- as.numeric(data[[varName]])
  #     }
  #   }
  # }

  # 3) This version uses Default priors
  # prior <- list(R = list(V = 1, fix = 1), # Residual variance
  #               G = list(G1 = list(V = 1, nu = 0.002))) # Random effect accepts multiple)
  #

  # 4) For each trait: Run the GibbsSampling
  set.seed(params$Seed) # Set seed for reproducibility
  Bunny_output<-list()

  for (n in seq_along(params$hTrait)) {
    cat("\n")
    cat(paste0(c("\nAnalysis for Trait ",params$hTrait[n]," in progress \n")))
    cat("---------------------------------------------------\n")

    # Define the model arguments common to all scenarios
    model_args <- list(
        fixed = as.formula(fixed_formula[[n]]),
        family = "gaussian",
        data = data,
        #prior = myPrior, If not specified, set to default
        nitt = params$iter,
        burnin = params$burnin,
        thin = params$lag,
        verbose = FALSE, #if TRUE MH diagnostics are printed to screen
        DIC = TRUE
      )

      # Add the random argument only if nRandom is different from 0
      if (length(params$hRand) > 0) {
        model_args$random <- as.formula(random_formula)
      }

      # Optionally, add priors if specified
      # if (!is.null(myPrior)) {
      #   model_args$prior <- myPrior
      # }

      # Use do.call to dynamically call MCMCglmm with the constructed arguments
      model <- do.call("MCMCglmm", model_args)

      cat("\n\n")
      cat("Features of posterior samples:\n")
      cat("---------------------------------------------------\n")
      cat("Number of iterations =", params$iter, "\n")
      cat("Burn-in =", params$burnin, "\n")
      cat("Lag =", params$lag, "\n")
      cat("Number of samples stored =", (params$iter - params$burnin) / params$lag, "\n")
      cat("---------------------------------------------------\n\n")
      cat("\n")
      cat("Model Evaluation Criterion:\n")
      cat("---------------------------------------------------\n")
      cat("DIC (Deviance Information Criterion) =", model$DIC, "\n")
      cat("---------------------------------------------------\n\n")


  # 5) For each trait: Check Chain Convergence
      # Convert the MCMCglmm object's Sol component to mcmc class
      mcmcSol <- as.mcmc(model$Sol)
      mcmcVar<- as.mcmc(model$VCV)
      # Rename the "Unit" subelement to "Ve" to improve understanding
      index <- which(colnames(mcmcVar) == "units")
      colnames(mcmcVar)[index] <- "Ve"

      # Plot trace plots for each parameter
      # plot(mcmcSol)
      # plot(mcmcVar)

      # Plot autocorrelation for each parameter
      # autocorr.plot(mcmcSol)
      # autocorr.plot(mcmcVar)

      #Plot Geweke-Brooks plot diagnostics
      # geweke.plot(mcmcSol)
      # geweke.plot(mcmcVar)

      # Calculate Geweke's diagnostic
      geweke_diag<-list()
      geweke_diag$Effects <- geweke.diag(mcmcSol)
      geweke_diag$VarianceComponents <- geweke.diag(mcmcVar)

      # Extract the Z-scores from the diagnostic
      z_scores<-list()
      z_scores$Effects <- geweke_diag[[1]]$z
      z_scores$VarianceComponents <- geweke_diag[[2]]$z


      cat("\n")
      cat("\nGeweke's Convergence Diagnostics Z-Scores Summary:\n")
      cat("---------------------------------------------------\n")
      # Iterate through the Z-scores to print a structured summary
      for (name in names(z_scores)) {
        cat(paste(name, "Z-Scores:\n"))
        if (length(z_scores[[name]]) > 0) {
          for (subname in names(z_scores[[name]])) {
            score <- z_scores[[name]][subname]
            # Highlight scores that might indicate an issue
            if (abs(score) > 2) {
              cat(paste("  ", subname, ": ", score, " (Potential issue with convergence)\n", sep = ""))
            } else {
              cat(paste("  ", subname, ": ", score, "\n", sep = ""))
            }
          }
        } else {
          cat("  No Z-scores available.\n")
        }
        cat("\n")
      }

      # Provide a brief explanation for users
      cat("Interpretation of Geweke's Z-Scores:\n")
      cat("Z-scores within the range of -2 to 2 generally indicate that the chain has converged to the target distribution.\n")
      cat("Z-scores outside this range may suggest issues with convergence, warranting further investigation.\n")
      cat("---------------------------------------------------\n\n")

      # Esto Agustin no lo usa
      # Calculate two-tailed p-values from the Z-scores
      # p_values <- 2 * pnorm(abs(z_scores), lower.tail = FALSE)

    # 6) For each trait: Compute the mean of the model and SD

      # Select columns from your data that match with hTreatment and hNoise #FALTA 1 INTER METERLAS AQUI!!
      columns_to_predict <- c(params$hTreatment, params$hNoise, params$hCov)
      data_to_predict <- data[, columns_to_predict, drop = FALSE]

      # Predict my data with my model and get the means (using all posterior samples of coefficients)
      model_formula <- as.formula(paste(" ~ ", predictors_formula))
      Xdata <- model.matrix(model_formula, data = data_to_predict)

      # Multiply the fixed effects design matrix (X) by the chains of coefficients to get predictions and Bind refGrid scenarios with their corresponding predictions
      Preddata <- Xdata %*% t(model$Sol[, colnames(Xdata)])

      #Make the mean
      ModelMean<-rowMeans(t(Preddata))
      Preddata_df <- data.frame(ModelMean)
      colnames(Preddata_df)<-params$hTrait[n]


  # 7) For each trait: Get Posterior chains of LSMeans (classical Rabbit)
    # Only if either Treatment, Noise or Inter exist
    # There is no LSMEANS package for MCMCglmm so I need to do my function by hand

    # Initialize the result list
    LSmeans <- list()

    # LSMeans function
    computeLSmeans<-function(params, data, model) {

        # Generate levels for treatments, noise, interactions and covariates levels based on provided information in param
        # Initialize an empty list for treatments, noise, and covariates levels
        categoricalAndCovariateVarsLevels <- list()

        # Generate levels for treatments if they exist (make sure they are factors)
        if (length(params$hTreatment) > 0) {
          treatmentsLevels <- lapply(params$hTreatment, function(tr) {
            factor(seq_len(params$nlevels_Treatment[params$hTreatment == tr]),
                   levels = seq_len(params$nlevels_Treatment[params$hTreatment == tr]))
          })
          names(treatmentsLevels) <- params$hTreatment
          categoricalAndCovariateVarsLevels <- c(categoricalAndCovariateVarsLevels, treatmentsLevels)
        }

        # Generate levels for noise if they exist (make sue thay are factors)
        if (length(params$hNoise) > 0) {
          noiseLevels <- lapply(params$hNoise, function(noise) {
            factor(seq_len(params$nlevels_Noise[params$hNoise == noise]),
                   levels = seq_len(params$nlevels_Noise[params$hNoise == noise]))
          })
          names(noiseLevels) <- params$hNoise
          categoricalAndCovariateVarsLevels <- c(categoricalAndCovariateVarsLevels, noiseLevels)
        }

        # Add covariates set to their mean values if they exist(make sure they are continuous)
        if (length(params$hCov) > 0) {
          for (cov in params$hCov) {
            categoricalAndCovariateVarsLevels[[cov]] <- mean(data[[cov]], na.rm = TRUE)
          }
        }

        #FALTA 4: PREGUNTAR AL USUARIO SI LAS INTERACCIONES SON RUIDO O TRATAMIENTO
        #FALTA 3: THIS IS TO BE CHANGED
        # # Check whether the both elements of each hInter row are already in th refGrid, and If not, add them
        # if (nrow(param$hInter) > 0) {
        #   # Loop through each row of hInter to handle each interaction pair
        #   for (i in 1:nrow(param$hInter)) {
        #     for (j in 1:ncol(param$hInter)) {
        #       var <- param$hInter[i, j]  # Current variable name from hInter
        #       varType <- param$typeInter[i, j]  # Corresponding type from typeInter
        #
        #       # Check if the variable has already been handled
        #       if (!(var %in% names(categoricalAndCovariateVarsLevels))) {
        #         if (varType == "F") {
        #           # Factor case: Generate levels based on unique non-NA values in data
        #           levelsCount <- length(unique(data[[var]][!is.na(data[[var]])]))
        #           categoricalAndCovariateVarsLevels[[var]] <- seq_len(levelsCount)
        #         } else if (varType == "C") {
        #           # Covariate case: Use a representative value, such as the mean
        #           categoricalAndCovariateVarsLevels[[var]] <- mean(data[[var]], na.rm = TRUE)
        #         }
        #       }
        #     }
        #   }


      # Create a reference grid for categorical variables and covariates
        refGrid <- expand.grid(categoricalAndCovariateVarsLevels) #Make sure Treatment and Noise are Factors
      # This is a double check; For factors, ensure they are treated as such in the refGrid
        for (varName in names(categoricalAndCovariateVarsLevels)) {
          if (varName %in% c(params$hTreatment, params$hNoise)) { #FALTA ITER
            #Convert to factor if not already
            refGrid[[varName]] <- factor(refGrid[[varName]])
          }
        }

      # Create the estimable function from the Grid
        model_formula <- as.formula(paste(" ~ ", predictors_formula))
        X <- model.matrix(model_formula, data = refGrid)

      # Multiply the fixed effects design matrix (X) by the chains of coefficients to get predictions and Bind refGrid scenarios with their corresponding predictions
        PredGrid <- X %*% t(model$Sol[, colnames(X)])
        PredGrid_df <- data.frame(PredGrid)
        combined_df <- cbind(refGrid, PredGrid_df)

      # Compute mean predictions by level
        lsmeans_results <- list() # Store LSMeans results
        all_factors <- c(params$hTreatment, params$hNoise) #Include here all factors which I want to compute LSMEANS FALTA 2 INTER

      # Make the means across all prediction with the same level for each factor
        for(factorVar in all_factors) {
          factor_lsmeans <- list() #Store results for each factor

          levels <- unique(combined_df[[factorVar]])
          for(level in levels) {

            # Filter rows for the current level
            rows_for_level <- combined_df[[factorVar]] == level

            # Extract the predictions for these rows and compute the mean across all rows
            predictions_for_level <- combined_df[rows_for_level, (ncol(combined_df) - ncol(PredGrid_df) + 1):ncol(combined_df)]
            mean_predictions <- apply(predictions_for_level, 2, mean)

            # Store the mean predictions for the current level
            factor_lsmeans[[as.character(level)]] <- mean_predictions
          }

          # Store the results for the current factor
          lsmeans_results[[factorVar]] <- factor_lsmeans
        }

      #Return lsmeans
      return(lsmeans_results)
    }

    # If any of hTreatment, hNoise, or hInter have a length greater than 0, compute LSMeans
    if (any(length(params$hTreatment) > 0, length(params$hNoise) > 0, length(params$hInter) > 0)) {

        #Compute Lsmeans
        cat("\nComputing Means... \n")
        LSmeans<- computeLSmeans(params, data, model)

        # Print summary of means and standard deviations of Tratments LSMeans
        # Check if names of LSMeans elements are in params$hTreatment
        treatment_names <- names(LSmeans)[names(LSmeans) %in% params$hTreatment]

        #If Treatments exist, display a summary
        if (length(treatment_names) > 0) {
             cat("\n Means computed! \n")
        } else {
          # Inform the user that no LSMeans are computed
          cat("\nNo Means computed as there are no fixed effects specified.\n")
        }
          cat("---------------------------------------------------\n")
    }

  # 8) For each trait: Compute differences or ratios between levels of Treatments if any

    # Differentiate between LSMeans of Treatments and Noise
    if (length(params$hTreatment) > 0) {
      # Filter LSMeans for treatments only
      treatMeans <- LSmeans[names(LSmeans) %in% params$hTreatment]
    } else {
      treatMeans <- list()
    }

    if (length(params$hNoise) > 0) {
      # Filter LSMeans for noise only
      noiseMeans <- LSmeans[names(LSmeans) %in% params$hNoise]
    } else {
      noiseMeans <- list()
    }

    # If there are any treatments specified, compute contrasts
    if (length(params$hTreatment) > 0) {
      cat("\nComputing Contrasts between levels of Treatment effects... \n")

      # Initialize a list to store contrasts
      contrasts_list <- list()

      # Iterate over each treatment
      for (treatment in params$hTreatment) {

      # Initialize an empty list for this treatment within contrasts_list
      contrasts_list[[treatment]] <- list()

      # Get the unique levels for the current treatment
      levels <- seq_len(params$nlevels_Treatment[params$hTreatment == treatment])

      # Compute pairwise combinations of levels
      level_combinations <- combn(levels, 2, simplify = FALSE)

      # Iterate over each combination to compute contrasts
      for (combination in level_combinations) {
        level1 <- combination[1]
        level2 <- combination[2]

        # Extract LSMeans for the current treatment and levels
        lsmean1 <- treatMeans[[treatment]][[as.character(level1)]]
        lsmean2 <- treatMeans[[treatment]][[as.character(level2)]]

        # Compute contrast based on user's choice
        if (params$askCompare == "D") {  # Difference
          contrast <- lsmean1 - lsmean2
          separator <- "-"
        } else if (params$askCompare == "R") {  # Ratio
          contrast <- lsmean1 / lsmean2
          separator <- "/"
        } else {
          stop("Invalid choice for askCompare. Please choose 'D' for difference or 'R' for ratio.")
        }

        # Construct the name for this particular contrast
        contrast_name <- paste(level1, separator, level2, sep="")

        # Store contrast in the appropriate treatment list within contrasts_list
        contrasts_list[[treatment]][[contrast_name]] <- contrast

      }
        cat("---------------------------------------------------\n")
     }
      cat(" Contrasts computed! ")
    } else {
      cat("\nNo Treatment effects specified. No contrasts to summarize.\n")
      contrasts_list <- list()
    }

  # 9) For each trait: extract samples for covariates estimates if any

    # Check if params$hCov is not NULL
    if (length(params$hCov) > 0) {
      # Extract the posterior samples of the covariates estimates
      covariates_samples <- as.data.frame(model$Sol[, colnames(model$Sol) %in% params$hCov])
      colnames(covariates_samples) <- colnames(model$Sol)[colnames(model$Sol) %in% params$hCov]
      cat(" Covariates computed! ")
    } else {covariates_samples<-list()}


  # 10) For each trait: extract the randomVariances samples if any

      # If its not null
      if (length(params$hRand) > 0) {

      # Extract the posterior samples for the random variances
      RandomVar_samples <- as.data.frame(model$VCV[, colnames(model$VCV) %in% params$hRand])
      colnames(RandomVar_samples) <- colnames(model$VCV)[colnames(model$VCV) %in% params$hRand]
      cat(" Variances of Random Effects computed! ")
    } else {RandomVar_samples<-list()}

  # 11) For each trait: Store the results in a list within trait

    # Bunny_output for the current trait
    bunny_trait <- list()
    bunny_trait$predictors <- fixed_formula[hTrait[n]]
    bunny_trait$random <- random_formula
    bunny_trait$Convergence <- z_scores
    bunny_trait$RandomVariances <- RandomVar_samples
    bunny_trait$ResVariance <- mcmcVar[, index, drop = FALSE]
    bunny_trait$treatMeans <- treatMeans
    bunny_trait$noiseMeans <- noiseMeans
    bunny_trait$Compare <- contrasts_list
    bunny_trait$Cov <- covariates_samples
    bunny_trait$ModelMean <- Preddata_df
    bunny_trait$DIC<-model$DIC


    # Store Bunny_output for the current trait
    Bunny_output[[params$hTrait[n]]] <- bunny_trait

  # 11) Only if user wants to write down the posterior chains
  if ((Chain) == TRUE) {

    # Iterate over each trait
    trait<-params$hTrait[n]

    # Create a new Excel workbook
    OUT <- createWorkbook()

    # Add worksheets for each type of posterior chain data
    addWorksheet(OUT, "ModelMean")
    writeData(OUT, sheet = "ModelMean", x = Preddata_df, colNames = TRUE, rowNames = FALSE)

    addWorksheet(OUT, "ResidualVariance")
    writeData(OUT, sheet = "ResidualVariance", x = mcmcVar[, index, drop = FALSE], colNames = TRUE, rowNames = FALSE)

    if (length(params$hRand) > 0) {
      addWorksheet(OUT, "RandomVariance")
      writeData(OUT, sheet = "RandomVariance", x = mcmcVar[, -index, drop = FALSE], colNames = TRUE, rowNames = FALSE)
    }

    if (length(params$hCov) > 0) {
      addWorksheet(OUT, "Covariate")
      writeData(OUT, sheet = "Covariate", x = covariates_samples, colNames = TRUE, rowNames = FALSE)
    }

    if (length(params$hTreatment) > 0) {

      addWorksheet(OUT, "Means")
      #Need to properly set up colnames as atm its a list
      treatMeans_df <- data.frame(matrix(ncol = 0, nrow = 1))
      for (treatment in names(treatMeans)) {
        levels <- treatMeans[[treatment]]
        col_names <- paste(treatment, seq_along(levels), sep = "")

        # Create a named list where each element will become a column
        levels_list <- setNames(as.list(levels), col_names)

        # Convert the named list directly into a single-row dataframe
        temp_df <- data.frame(levels_list, check.names = FALSE)

        # Combine the temp_df with treatMeans_df. Now both dataframes should have 1 row.
        treatMeans_df <- cbind(treatMeans_df, temp_df)
      }
      writeData(OUT, sheet = "Means", x = treatMeans_df, colNames = TRUE, rowNames = FALSE)

      addWorksheet(OUT, "Contrasts")
      #Need to properly set up colnames as atm its a list
      #contrasts_df <- as.data.frame(contrasts_list)
      contrasts_df <- data.frame(matrix(ncol = 0, nrow = 1))
      for (contr in names(contrasts_list)) {
        levels <- contrasts_list[[contr]]
        col_names <- paste(contr, names(levels), sep = "_")

        # Create a named list where each element will become a column
        levels_list <- setNames(as.list(levels), col_names)

        # Convert the named list directly into a single-row dataframe
        temp_df <- data.frame(levels_list, check.names = FALSE)

        # Combine the temp_df with contrasts_df. Now both dataframes should have 1 row.
        contrasts_df <- cbind(contrasts_df, temp_df)
      }
      writeData(OUT, sheet = "Contrasts", x = contrasts_df, colNames = TRUE, rowNames = FALSE)
    }

    # Construct the file name with the trait name
    file_name <- paste0("PosteriorChains_", trait, ".xlsx")

    # Save the workbook to a file named "PosteriorChains.xlsx"
    saveWorkbook(OUT, file_name, overwrite = TRUE)
    cat("Posterior samples for trait ", trait, " are saved ! \n")
    cat("---------------------------------------------------\n")
    }

} #End of the Loop for each trait

  return(Bunny_output)
  cat(" Bunny finished. The posterior chains of your estimates are ready ! :) \n")
  cat("---------------------------------------------------\n")

} #End of the Function Bunny







